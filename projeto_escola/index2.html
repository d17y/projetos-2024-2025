<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" /> <!-- Permite acentuação -->
  <meta name="viewport" content="width=device-width,initial-scale=1" /> <!-- Responsivo -->
  <title>Verificação Facial - Demo</title>
  <style>
    /* Layout e aparência */
    body{ margin:0; font-family:Arial,Helvetica,sans-serif;      background: linear-gradient(to bottom, #d6f817, #bec928); /* Fundo degradê */; color:#fff; min-height:100vh; display:flex; align-items:center; justify-content:center; }
    .card{ width:90%; max-width:760px; background:rgba(0,0,0,0.22); padding:20px; border-radius:12px; box-shadow:0 8px 28px rgba(0,0,0,0.35); text-align:center; }
    video, canvas{ border-radius:8px; background:#222; max-width:100%; }
    .row{ display:flex; gap:12px; flex-wrap:wrap; justify-content:center; margin-top:12px; }
    .col{ flex:1 1 220px; min-width:220px; max-width:320px; }
    button{ padding:10px 14px; border-radius:10px; border:none; cursor:pointer; font-weight:600; }
    .btn-primary{ background:#004d63; color:#fff; }
    .btn-ghost{ background:rgba(255,255,255,0.9); color:#004d63; }
    .msg{ margin-top:12px; min-height:24px; font-weight:700; }
    small{ display:block; margin-top:8px; color:#dff6ff; }
    label{ display:block; text-align:left; font-size:14px; margin-bottom:6px; color:#dff6ff; }
    input[type=range]{ width:100%; }
  </style>
</head>
<body>
  <div class="card">
    <h2>Verificação Facial (demo)</h2>
    <p style="margin:6px 0 12px">Abra a câmera, registre um rosto (foto de referência) e depois verifique capturando nova foto. Comparação: MSE em imagem reduzida — protótipo.</p>

    <!-- vídeo ao vivo -->
    <div class="row">
      <div class="col">
        <label>Vídeo da câmera</label>
        <video id="video" autoplay playsinline width="320" height="240"></video>
        <small>Permita a câmera quando o navegador pedir.</small>
      </div>

      <div class="col">
        <label>Foto capturada (preview)</label>
        <canvas id="preview" width="320" height="240"></canvas>
        <small>Preview da captura que será comparada com a referência.</small>
      </div>
    </div>

    <!-- controles -->
    <div class="row" style="margin-top:14px">
      <button id="btnStart" class="btn-primary">Abrir câmera</button>
      <button id="btnCapture" class="btn-primary">Capturar foto</button>
      <button id="btnRegister" class="btn-ghost">Registrar rosto (salvar referência)</button>
      <button id="btnVerify" class="btn-primary">Verificar rosto</button>
      <button id="btnClear" class="btn-ghost">Limpar referência</button>
    </div>

    <!-- ajuste de limiar e mensagens -->
    <div style="margin-top:10px; text-align:left; max-width:600px; margin-left:auto; margin-right:auto;">
      <label>Limiar de aceitação (quanto menor = mais rigoroso)</label>
      <input id="thresh" type="range" min="100" max="5000" value="1200" />
      <small>Valor atual: <span id="threshVal">1200</span> (ajuste conforme seus testes)</small>
    </div>

    <div class="msg" id="msg">Referência atual: <span id="refStatus">nenhuma</span></div>
    <small>⚠️ Demo local. Para verificação real use serviços/provedores especializados e garanta privacidade/consentimento.</small>
  </div>

<script>
/*
  Exemplo de verificação facial (prototipo):
  - getUserMedia para acessar câmera
  - captura frame para canvas
  - registra referência (imagem reduzida) no localStorage
  - compara captura atual com referência via MSE em imagem reduzida
  - se passar, marca usuário como verificado e redireciona para index3.html
*/

/* Elementos do DOM */
const video = document.getElementById('video');              // vídeo ao vivo
const preview = document.getElementById('preview');          // canvas preview
const ctx = preview.getContext('2d');                        // contexto do canvas
const btnStart = document.getElementById('btnStart');        // abrir câmera
const btnCapture = document.getElementById('btnCapture');    // capturar
const btnRegister = document.getElementById('btnRegister');  // registrar referência
const btnVerify = document.getElementById('btnVerify');      // verificar
const btnClear = document.getElementById('btnClear');        // limpar referência
const msg = document.getElementById('msg');                  // área de mensagens
const refStatus = document.getElementById('refStatus');      // mostra status da referência
const threshInput = document.getElementById('thresh');      // slider limiar
const threshVal = document.getElementById('threshVal');      // mostra valor limiar

/* Estado e constantes */
let stream = null;                                           // MediaStream da câmera
const REF_KEY = 'face_reference_img_v1';                     // chave localStorage da referência
const SMALL_W = 64;                                          // largura reduzida usada na comparação
const SMALL_H = 64;                                          // altura reduzida

/* Função: atualiza o status da referência exibido */
function updateRefStatus(){
  const ref = localStorage.getItem(REF_KEY);
  refStatus.innerText = ref ? 'salva' : 'nenhuma';
}
updateRefStatus(); // chama ao carregar

/* Atualiza valor do slider enquanto o usuário mexe */
threshInput.addEventListener('input', ()=>{ threshVal.innerText = threshInput.value; });

/* Inicia a câmera (pede permissão) */
async function startCamera(){
  try{
    stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 }, audio: false });
    video.srcObject = stream; // mostra o stream no elemento video
    showMessage('Câmera ativada. Posicione seu rosto e clique em "Capturar foto".', 'rgba(0,128,0,0.08)');
  } catch(err){
    console.error(err);
    showMessage('Erro ao abrir a câmera: ' + (err.message || err), 'rgba(255,80,80,0.2)');
  }
}

/* Captura frame do vídeo para o canvas preview e retorna dataURL */
function captureToCanvas(){
  if(!stream){ showMessage('Câmera não está ativa. Clique em "Abrir câmera".', 'rgba(255,140,0,0.15)'); return null; }
  ctx.drawImage(video, 0, 0, preview.width, preview.height); // desenha frame no canvas
  showMessage('Foto capturada (preview).');
  return preview.toDataURL('image/png'); // retorna imagem como dataURL
}

/* Converte uma dataURL de imagem para um array grayscale reduzido SMALL_W x SMALL_H */
function imageDataToSmallGray(imgDataUrl){
  return new Promise((resolve,reject)=>{
    const img = new Image();
    img.onload = ()=>{
      const c = document.createElement('canvas');
      c.width = SMALL_W; c.height = SMALL_H;
      const cctx = c.getContext('2d');
      cctx.drawImage(img, 0, 0, SMALL_W, SMALL_H); // redimensiona para pequeno
      const d = cctx.getImageData(0,0,SMALL_W,SMALL_H).data;
      const gray = new Float32Array(SMALL_W*SMALL_H);
      for(let i=0, j=0;i<d.length;i+=4, j++){
        const r = d[i], g = d[i+1], b = d[i+2];
        gray[j] = 0.299*r + 0.587*g + 0.114*b; // luminância
      }
      resolve(gray);
    };
    img.onerror = (e)=> reject(e);
    img.src = imgDataUrl;
  });
}

/* Calcula MSE entre dois arrays Float32 (mesmo tamanho) */
function mse(a,b){
  let s=0;
  for(let i=0;i<a.length;i++){
    const diff = a[i]-b[i];
    s += diff*diff;
  }
  return s / a.length;
}

/* Registra referência: captura, reduz e salva no localStorage */
async function registerReference(){
  const dataUrl = captureToCanvas(); // captura do vídeo
  if(!dataUrl) return;
  showMessage('Processando referência...', 'rgba(0,128,0,0.06)');
  try{
    const gray = await imageDataToSmallGray(dataUrl);
    // salvamos visual (dataURL) para possível visualização e vetor gray para comparação
    localStorage.setItem(REF_KEY, JSON.stringify({ visual: dataUrl, gray: Array.from(gray), created: Date.now() }));
    updateRefStatus(); // atualiza texto "salva"
    showMessage('Referência salva com sucesso.', 'rgba(0,128,0,0.12)');
  }catch(e){
    console.error(e);
    showMessage('Erro ao processar referência.', 'rgba(255,80,80,0.2)');
  }
}

/* Verifica: captura atual, reduz, compara com referência via MSE */
async function verifyFace(){
  const refRaw = localStorage.getItem(REF_KEY);
  if(!refRaw){ showMessage('Nenhuma referência salva. Registre um rosto primeiro.', 'rgba(255,140,0,0.15)'); return; }
  const refObj = JSON.parse(refRaw); // pega referência salva
  const dataUrl = captureToCanvas(); // captura atual
  if(!dataUrl) return;
  showMessage('Comparando...', 'rgba(0,128,0,0.04)');
  try{
    // gera vetores reduzidos: referência (salva) e atual
    const [a,b] = await Promise.all([
      Promise.resolve(new Float32Array(refObj.gray)),
      imageDataToSmallGray(dataUrl)
    ]);
    const dist = mse(a,b); // distância (MSE)
    const limiar = Number(threshInput.value); // limiar escolhido
    showMessage('Distância (MSE): ' + Math.round(dist) + ' — limiar: ' + limiar);
    if(dist <= limiar){
      // SUCESSO: marcar usuário verificado e redirecionar
      showMessage('✅ Face verificada! Redirecionando...', 'rgba(0,128,0,0.15)');

      // marca o usuário logado como verificado no banco local (localStorage)
      try{
        const cpf = localStorage.getItem('ultimo_cpf_logado'); // recupera CPF que entrou
        if(cpf){
          const usersRaw = localStorage.getItem('banco_usuarios') || '{}';
          const users = JSON.parse(usersRaw);
          if(users[cpf]){
            users[cpf].verificado = true; // marca verificado
            localStorage.setItem('banco_usuarios', JSON.stringify(users)); // salva de volta
          }
        }
      }catch(e){
        console.warn('Erro ao marcar usuário verificado:', e);
      }

      // para a câmera (melhor prática) antes do redirect
      if(stream){
        stream.getTracks().forEach(t => t.stop());
      }

      // redireciona para index3.html após 1s
      setTimeout(()=> { window.location.href = 'index3.html'; }, 1000);
    } else {
      // FALHA: não corresponde
      showMessage('❌ Face não corresponde. Tente novamente (ou registre/ajuste limiar).', 'rgba(255,0,0,0.2)');
    }
  }catch(e){
    console.error(e);
    showMessage('Erro na verificação.', 'rgba(255,80,80,0.2)');
  }
}

/* Remove referência salva */
function clearReference(){
  localStorage.removeItem(REF_KEY);
  updateRefStatus();
  showMessage('Referência removida.');
}

/* Exibe mensagem no elemento de mensagem */
function showMessage(txt, bg='transparent'){ msg.innerText = txt; msg.style.background = bg; msg.style.color = '#fff'; }

/* Eventos dos botões */
btnStart.addEventListener('click', startCamera);         // abre a câmera
btnCapture.addEventListener('click', ()=>{ captureToCanvas(); }); // captura preview
btnRegister.addEventListener('click', registerReference); // registra referência
btnVerify.addEventListener('click', verifyFace);          // verifica e pode redirecionar
btnClear.addEventListener('click', clearReference);       // limpa referência

/* Interrompe a câmera quando a página for fechada/saída */
window.addEventListener('beforeunload', ()=>{
  if(stream){
    stream.getTracks().forEach(t=>t.stop());
  }
});
</script>
</body>
</html>
